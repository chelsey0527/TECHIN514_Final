/* Generated by Edge Impulse
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
// Generated on: 28.02.2024 01:18:08

#include <stdio.h>
#include <stdlib.h>
#include "edge-impulse-sdk/tensorflow/lite/c/builtin_op_data.h"
#include "edge-impulse-sdk/tensorflow/lite/c/common.h"
#include "edge-impulse-sdk/tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "edge-impulse-sdk/porting/ei_classifier_porting.h"

#if EI_CLASSIFIER_PRINT_STATE
#if defined(__cplusplus) && EI_C_LINKAGE == 1
extern "C" {
    extern void ei_printf(const char *format, ...);
}
#else
extern void ei_printf(const char *format, ...);
#endif
#endif

#if defined __GNUC__
#define ALIGN(X) __attribute__((aligned(X)))
#elif defined _MSC_VER
#define ALIGN(X) __declspec(align(X))
#elif defined __TASKING__
#define ALIGN(X) __align(X)
#elif defined __ICCARM__
#define ALIGN(x) __attribute__((aligned(x)))
#endif

#ifndef EI_MAX_SCRATCH_BUFFER_COUNT
#ifndef CONFIG_IDF_TARGET_ESP32S3
#define EI_MAX_SCRATCH_BUFFER_COUNT 4
#else
#define EI_MAX_SCRATCH_BUFFER_COUNT 4
#endif // CONFIG_IDF_TARGET_ESP32S3
#endif // EI_MAX_SCRATCH_BUFFER_COUNT

#ifndef EI_MAX_OVERFLOW_BUFFER_COUNT
#define EI_MAX_OVERFLOW_BUFFER_COUNT 10
#endif // EI_MAX_OVERFLOW_BUFFER_COUNT

using namespace tflite;
using namespace tflite::ops;
using namespace tflite::ops::micro;

namespace {

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX) || defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
constexpr int kTensorArenaSize = 1520;
#else
constexpr int kTensorArenaSize = 496;
#endif

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX)
#pragma Bss(".tensor_arena")
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#pragma Bss()
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) __attribute__((section(".tensor_arena")));
#else
#define EI_CLASSIFIER_ALLOCATION_HEAP 1
uint8_t* tensor_arena = NULL;
#endif

static uint8_t* tensor_boundary;
static uint8_t* current_location;

template <int SZ, class T> struct TfArray {
  int sz; T elem[SZ];
};

enum used_operators_e {
  OP_FULLY_CONNECTED, OP_SOFTMAX,  OP_LAST
};

struct TensorInfo_t { // subset of TfLiteTensor used for initialization from constant memory
  TfLiteAllocationType allocation_type;
  void* data;
  TfLiteIntArray* dims;
  size_t bytes;
};

typedef struct {
  TfLiteTensor tensor;
  int16_t index;
} TfLiteTensorWithIndex;

typedef struct {
  TfLiteEvalTensor tensor;
  int16_t index;
} TfLiteEvalTensorWithIndex;

TfLiteContext ctx{};
static const int MAX_TFL_TENSOR_COUNT = 4;
static TfLiteTensorWithIndex tflTensors[MAX_TFL_TENSOR_COUNT];
static const int MAX_TFL_EVAL_COUNT = 4;
static TfLiteEvalTensorWithIndex tflEvalTensors[MAX_TFL_EVAL_COUNT];
TfLiteRegistration registrations[OP_LAST];

namespace g0 {
const TfArray<2, int> tensor_dimension0 = { 2, { 1,21 } };
const ALIGN(16) float tensor_data1[10] = { -0.0094712758436799049, 0, 0, -0.0087729915976524353, 0.0060642310418188572, 0.0049139563925564289, -0.020347926765680313, 0.03023916482925415, -0.030389156192541122, -0.024099079892039299, };
const TfArray<1, int> tensor_dimension1 = { 1, { 10 } };
const ALIGN(16) float tensor_data2[20] = { -0.0070860404521226883, 0.029074134305119514, 0, 0.020563207566738129, -0.014842254109680653, 0.010158885270357132, -0.026435958221554756, 0, 0.028524627909064293, 0.033171582967042923, -0.019154520705342293, 0, 0, 0.029376337304711342, 0, -0.0063042221590876579, -0.037322714924812317, -0.018860809504985809, 0.034652773290872574, 0.038767449557781219, };
const TfArray<1, int> tensor_dimension2 = { 1, { 20 } };
const ALIGN(8) float tensor_data3[2] = { -0.028176348656415939, 0.02817634679377079, };
const TfArray<1, int> tensor_dimension3 = { 1, { 2 } };
const ALIGN(16) float tensor_data4[20*21] = { 
  -0.008715679869055748, -0.059961996972560883, -0.09065815806388855, 0.30477803945541382, 0.1068381667137146, 0.18315038084983826, 0.11510723084211349, -0.24901621043682098, 0.11799494922161102, -0.30852699279785156, -0.018849493935704231, 0.13469067215919495, -0.33333158493041992, -0.23784439265727997, -0.088981524109840393, 0.32481488585472107, 0.086726710200309753, 0.26565924286842346, -0.1825023740530014, -0.1814548671245575, 0.33125090599060059, 
  -0.34131348133087158, 0.0036337594501674175, 0.33682927489280701, 0.076308287680149078, -0.11079177260398865, 0.06270173192024231, 0.089123480021953583, 0.14265647530555725, 0.19497576355934143, 0.37668675184249878, -0.21211618185043335, 0.15719214081764221, 0.050374299287796021, 0.040197744965553284, 0.26042628288269043, -0.17269580066204071, 0.32279610633850098, 0.21517640352249146, 0.38132968544960022, -0.22540059685707092, -0.092228926718235016, 
  0.24429163336753845, -0.04985615611076355, -0.32345280051231384, -0.26787090301513672, 0.16321119666099548, -0.19852636754512787, 0.23154780268669128, 0.31713250279426575, 0.3608795702457428, -0.032660454511642456, -0.28493911027908325, 0.06126740574836731, -0.27475512027740479, 0.18259575963020325, -0.22011776268482208, 0.26263174414634705, 0.12274113297462463, 0.22194495797157288, 0.0049406290054321289, 0.16065219044685364, 0.37564685940742493, 
  -0.28659698367118835, 0.22419311106204987, -0.17369864881038666, 0.25035113096237183, -0.031235247850418091, 0.21957346796989441, -0.057494599372148514, 0.39138978719711304, 0.21323800086975098, -0.29327574372291565, 0.33298718929290771, 0.30196729302406311, 0.18291851878166199, 0.2122323215007782, 0.18771742284297943, -0.058487411588430405, -0.2624199390411377, -0.15727193653583527, 0.12533482909202576, 0.23790177702903748, -0.26775676012039185, 
  0.29285988211631775, 0.061788257211446762, 0.045900549739599228, -0.25360047817230225, -0.30076137185096741, -0.28385204076766968, 0.33083537220954895, -0.10801541805267334, -0.1955120861530304, 0.20515049993991852, -0.12786731123924255, 0.068708539009094238, -0.23764264583587646, -0.15327355265617371, -0.27852359414100647, 0.18669047951698303, 0.20160076022148132, 0.23106740415096283, -0.032890737056732178, -0.088567405939102173, -0.027755983173847198, 
  -0.11718606948852539, 0.27931657433509827, 0.062771707773208618, -0.020625365898013115, -0.12783235311508179, -0.2997821569442749, 0.026497038081288338, 0.37766382098197937, -0.14624379575252533, 0.08307097852230072, -0.35217070579528809, -0.13649912178516388, -0.3733045756816864, 0.16580308973789215, 0.067532479763031006, -0.0049849455244839191, -0.34032103419303894, 0.10940636694431305, -0.11657506227493286, 0.031987160444259644, -0.30466815829277039, 
  0.16660742461681366, -0.12421879172325134, -0.15257091820240021, -0.22433933615684509, -0.23400324583053589, -0.3702927827835083, -0.097757823765277863, 0.24881516396999359, -0.15343029797077179, 0.011298444122076035, -0.035057488828897476, -0.0284271240234375, 0.003747105598449707, 0.24675634503364563, 0.13073070347309113, -0.078359685838222504, -0.17109023034572601, -0.21085689961910248, 0.37125816941261292, 0.29312935471534729, -0.15287379920482635, 
  0.27821084856987, -0.37260895967483521, 0.1061646044254303, 0.32147601246833801, 0.32742747664451599, 0.10770991444587708, 0.10236960649490356, 0.15259924530982971, -0.12186235189437866, 0.3162020742893219, -0.08251267671585083, 0.36297020316123962, -0.1352582573890686, 0.14691439270973206, -0.24833199381828308, -0.36517283320426941, -0.12674281001091003, -0.20323880016803741, -0.25671237707138062, 0.35109534859657288, 0.31097671389579773, 
  0.23556777834892273, 0.39132124185562134, 0.25525832176208496, -0.03643900528550148, -0.32505685091018677, 0.2344914972782135, -0.072991080582141876, -0.19610238075256348, -0.0029280830640345812, -0.032447591423988342, 0.053233429789543152, 0.23149189352989197, 0.21954372525215149, -0.16658724844455719, 0.08897814154624939, -0.13412685692310333, 0.18369768559932709, -0.1481221616268158, 0.37408986687660217, 0.07732623815536499, 0.31866440176963806, 
  -0.33359020948410034, 0.15372584760189056, -0.33875548839569092, -0.041160695254802704, -0.2204352468252182, 0.22528889775276184, -0.3790152370929718, -0.018986152485013008, -0.22445319592952728, -0.39874395728111267, -0.34077802300453186, -0.26055663824081421, -0.38086265325546265, -0.1317337304353714, -0.2465970516204834, 0.29260188341140747, -0.045507285743951797, 0.2176598459482193, 0.26752063632011414, -0.24212880432605743, -0.11211976408958435, 
  0.339800626039505, 0.063675038516521454, 0.14668554067611694, -0.38914385437965393, -0.29950273036956787, -0.15182000398635864, 0.24000664055347443, 0.037180919200181961, -0.047345768660306931, 0.10173948109149933, -0.31185555458068848, 0.11416074633598328, 0.10088807344436646, -0.27534973621368408, 0.15619036555290222, -0.24395789206027985, -0.030429176986217499, -0.027208678424358368, 0.1342291533946991, 0.08219417929649353, -0.30349165201187134, 
  -0.051963299512863159, 0.12817391753196716, 0.33715412020683289, -0.11499208211898804, -0.29057154059410095, -0.33855414390563965, 0.37660351395606995, -0.14916372299194336, 0.27827033400535583, -0.088161975145339966, 0.324980229139328, 0.34849509596824646, 0.24155345559120178, 0.34529969096183777, -0.14038494229316711, 0.17185196280479431, -0.15740774571895599, -0.13335651159286499, 0.34171757102012634, 0.010182976722717285, -0.085426986217498779, 
  -0.174332395195961, -0.36255732178688049, 0.0039602518081665039, -0.12177261710166931, 0.23001846671104431, -0.32755306363105774, -0.22655709087848663, -0.36888355016708374, -0.30692952871322632, 0.18182477355003357, -0.088066220283508301, -0.35154235363006592, 0.093161910772323608, 0.20213016867637634, -0.13180026412010193, 0.27936777472496033, 0.048371225595474243, -0.12836846709251404, 0.31505683064460754, -0.10329309105873108, 0.17747172713279724, 
  0.11789178848266602, -0.35273590683937073, -0.17916737496852875, 0.0074398387223482132, 0.33876559138298035, 0.36755165457725525, -0.34949943423271179, 0.3791949450969696, -0.026271238923072815, 0.1154659241437912, 0.097655013203620911, 0.10026812553405762, 0.33489194512367249, 0.072288289666175842, -0.046618055552244186, -0.24361908435821533, -0.35500499606132507, -0.035475671291351318, -0.30767905712127686, -0.14118856191635132, -0.32028967142105103, 
  0.34437748789787292, -0.32132568955421448, -0.20630605518817902, 0.072813659906387329, 0.025263994932174683, -0.22663362324237823, -0.17055810987949371, 0.12840238213539124, 0.17797115445137024, 0.12480047345161438, 0.3652101457118988, -0.37720510363578796, -0.32616737484931946, 0.36595311760902405, -0.37307345867156982, -0.14729462563991547, -0.33672711253166199, 0.048912167549133301, 0.21294429898262024, -0.30087053775787354, 0.31785574555397034, 
  0.019296852871775627, 0.33993101119995117, -0.26276054978370667, -0.33742201328277588, -0.35511773824691772, 0.10320669412612915, -0.040158495306968689, 0.078974723815917969, 0.15496112406253815, 0.14271844923496246, -0.0061319600790739059, 0.14581820368766785, -0.21194697916507721, 0.18340076506137848, 0.19470852613449097, 0.31005203723907471, 0.078659459948539734, 0.18360167741775513, 0.13280919194221497, 0.22393056750297546, -0.34066838026046753, 
  -0.034559048712253571, -0.28356838226318359, -0.19049647450447083, -0.067126907408237457, 0.30748715996742249, -0.090668231248855591, -0.090370416641235352, -0.31185758113861084, 0.10070910304784775, -0.37161290645599365, -0.36900249123573303, -0.11984744668006897, 0.088040322065353394, 0.2222604900598526, -0.16983944177627563, 0.10034894943237305, -0.3378203809261322, -0.22719976305961609, 0.16494253277778625, -0.12295901775360107, -0.2814352810382843, 
  -0.090406171977519989, 0.16843356192111969, 0.31934946775436401, 0.24907621741294861, 0.27604112029075623, -0.11742427945137024, -0.12920604646205902, 0.29871863126754761, 0.1127421036362648, -0.06722191721200943, -0.15227004885673523, 0.36948296427726746, -0.13417299091815948, 0.28802797198295593, -0.28969383239746094, -0.14510490000247955, -0.28309369087219238, 0.080895423889160156, 0.34980759024620056, -0.20633095502853394, 0.22185181081295013, 
  -0.3338315486907959, -0.1112811267375946, 0.18796288967132568, -0.3850119411945343, 0.18341568112373352, 0.03216254711151123, -0.28201791644096375, -0.050356116145849228, -0.025292575359344482, -0.14814749360084534, -0.36570566892623901, -0.14548373222351074, -0.32481268048286438, -0.30367237329483032, -0.27888703346252441, -0.1935187429189682, 0.028838932514190674, -0.21988469362258911, -0.20789997279644012, 0.14566603302955627, -0.22370953857898712, 
  0.0074757793918251991, 0.30554363131523132, 0.03980560228228569, -0.16642637550830841, -0.064942836761474609, -0.12490636110305786, 0.074478261172771454, -0.028066560626029968, 0.29559734463691711, 0.28016546368598938, -0.28504201769828796, 0.30074486136436462, 0.26168683171272278, -0.04313649982213974, 0.018785810098052025, -0.13088567554950714, 0.014369159936904907, -0.29340007901191711, -0.20231752097606659, 0.10250496864318848, -0.18247145414352417, 
};
const TfArray<2, int> tensor_dimension4 = { 2, { 20,21 } };
const ALIGN(16) float tensor_data5[10*20] = { 
  0.155190110206604, -0.3033810555934906, -0.2588837742805481, 0.03886524960398674, 0.37262696027755737, 0.051111005246639252, 0.43442118167877197, -0.4011930525302887, -0.031184742227196693, -0.20282949507236481, 0.080035611987113953, 0.071906685829162598, 0.24257105588912964, 0.42554691433906555, 0.20777857303619385, -0.3256116509437561, 0.00019213557243347168, -0.10665715485811234, -0.27790206670761108, 0.085752785205841064, 
  -0.21513541042804718, -0.43652644753456116, 0.25989925861358643, 0.25670373439788818, 0.20556908845901489, -0.15646842122077942, -0.19914223253726959, -0.36983609199523926, -0.35554879903793335, 0.069873809814453125, -0.20073221623897552, -0.2023371160030365, 0.2409820556640625, 0.084498703479766846, 0.26755255460739136, 0.3430597186088562, -0.19190970063209534, 0.13136303424835205, -0.1693665087223053, -0.11774033308029175, 
  -0.086540102958679199, -0.36983108520507812, -0.011426568031311035, 0.40303337574005127, -0.18503651022911072, -0.22609998285770416, -0.13627669215202332, 0.078819572925567627, -0.15676471590995789, -0.043710947036743164, 0.12338340282440186, 0.19389015436172485, -0.081969767808914185, -0.33017858862876892, -0.050489902496337891, -0.26666605472564697, 0.32243669033050537, -0.3727266788482666, -0.38322222232818604, -0.30915829539299011, 
  0.21889331936836243, 0.030069125816226006, 0.35992997884750366, -0.0062689171172678471, -0.26808229088783264, 0.27709075808525085, -0.20377501845359802, -0.17520973086357117, -0.13364262878894806, 0.31824254989624023, 0.37078312039375305, 0.18503981828689575, -0.28030186891555786, -0.32615876197814941, -0.016391962766647339, -0.18415437638759613, -0.071074165403842926, -0.2236226350069046, 0.44151914119720459, 0.31185045838356018, 
  -0.17945292592048645, 0.21269281208515167, -0.36935180425643921, -0.17140966653823853, -0.33365142345428467, 0.25901958346366882, -0.11892746388912201, 0.10276287794113159, -0.37426087260246277, 0.27153879404067993, 0.34589836001396179, 0.21861153841018677, -0.077009856700897217, 0.22282622754573822, 0.094670414924621582, -0.36467123031616211, -0.15581290423870087, 0.37286359071731567, 0.31458044052124023, 0.22671771049499512, 
  -0.33576247096061707, 0.27344074845314026, -0.2659904956817627, 0.19961676001548767, -0.11161044985055923, -0.44155547022819519, -0.025772631168365479, 0.29864662885665894, -0.44022196531295776, -0.17979496717453003, 0.30180662870407104, 0.22912448644638062, -0.19458532333374023, 0.24370640516281128, -0.091879725456237793, -0.25415390729904175, -0.14094427227973938, 0.24146972596645355, -0.25955837965011597, 0.020186567679047585, 
  0.34588170051574707, 0.16035184264183044, -0.22562752664089203, -0.32302355766296387, 0.28932827711105347, 0.28290209174156189, 0.05667109414935112, -0.12744566798210144, -0.122352235019207, 0.024372447282075882, 0.21983525156974792, 0.15596038103103638, -0.27470189332962036, -0.14953632652759552, 0.034872889518737793, -0.088175475597381592, 0.24365384876728058, -0.085792616009712219, -0.047048468142747879, -0.14482562243938446, 
  -0.051415644586086273, 0.38606390357017517, 0.17830127477645874, 0.27512055635452271, -0.023491963744163513, 0.35953497886657715, 0.31554895639419556, -0.42450523376464844, 0.47327351570129395, -0.15199409425258636, -0.19847023487091064, 0.4315333366394043, 0.25406181812286377, -0.10515789687633514, -0.38276225328445435, 0.223387211561203, 0.29882737994194031, 0.04313327744603157, 0.015068898908793926, 0.36061394214630127, 
  0.23281177878379822, 0.11909380555152893, 0.20962709188461304, 0.11745871603488922, 0.31443804502487183, 0.098498925566673279, -0.41686040163040161, -0.099663406610488892, -0.14882554113864899, 0.027796193957328796, 0.33627527952194214, 0.081783950328826904, -0.018651306629180908, -0.44669914245605469, -0.1313498318195343, 0.33394327759742737, -0.33315008878707886, 0.24977409839630127, -0.20052807033061981, -0.1747792661190033, 
  0.1624419242143631, -0.30282497406005859, -0.061477065086364746, -0.041086357086896896, 0.29025709629058838, 0.36232659220695496, -0.076080828905105591, 0.041086941957473755, 0.26784893870353699, -0.35648933053016663, -0.25159049034118652, 0.18616098165512085, -0.28586220741271973, -0.24500679969787598, 0.21444606781005859, -0.095898941159248352, -0.070471644401550293, 0.3194480836391449, 0.010248482227325439, 0.25439181923866272, 
};
const TfArray<2, int> tensor_dimension5 = { 2, { 10,20 } };
const ALIGN(16) float tensor_data6[2*10] = { 
  0.40075495839118958, -0.56808286905288696, 0.40211349725723267, 0.63265806436538696, 0.73058164119720459, -0.44925418496131897, -0.26101288199424744, -0.63521546125411987, 0.033318795263767242, 0.47401034832000732, 
  0.39562639594078064, 0.079585075378417969, -0.12610673904418945, -0.16518302261829376, -0.57805311679840088, 0.0031109531410038471, -0.64021152257919312, 0.34679245948791504, -0.50530731678009033, 0.22162234783172607, 
};
const TfArray<2, int> tensor_dimension6 = { 2, { 2,10 } };
const TfArray<2, int> tensor_dimension7 = { 2, { 1,20 } };
const TfArray<2, int> tensor_dimension8 = { 2, { 1,10 } };
const TfArray<2, int> tensor_dimension9 = { 2, { 1,2 } };
const TfArray<2, int> tensor_dimension10 = { 2, { 1,2 } };
const TfLiteFullyConnectedParams opdata0 = { kTfLiteActRelu, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs0 = { 3, { 0,4,2 } };
const TfArray<1, int> outputs0 = { 1, { 7 } };
const TfLiteFullyConnectedParams opdata1 = { kTfLiteActRelu, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs1 = { 3, { 7,5,1 } };
const TfArray<1, int> outputs1 = { 1, { 8 } };
const TfLiteFullyConnectedParams opdata2 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs2 = { 3, { 8,6,3 } };
const TfArray<1, int> outputs2 = { 1, { 9 } };
const TfLiteSoftmaxParams opdata3 = { 1 };
const TfArray<1, int> inputs3 = { 1, { 9 } };
const TfArray<1, int> outputs3 = { 1, { 10 } };
};

TensorInfo_t tensorData[] = {
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension0, 84, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data1, (TfLiteIntArray*)&g0::tensor_dimension1, 40, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data2, (TfLiteIntArray*)&g0::tensor_dimension2, 80, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data3, (TfLiteIntArray*)&g0::tensor_dimension3, 8, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data4, (TfLiteIntArray*)&g0::tensor_dimension4, 1680, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data5, (TfLiteIntArray*)&g0::tensor_dimension5, 800, },
{ kTfLiteMmapRo, (int32_t*)g0::tensor_data6, (TfLiteIntArray*)&g0::tensor_dimension6, 80, },
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 96), (TfLiteIntArray*)&g0::tensor_dimension7, 80, },
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension8, 40, },
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 48), (TfLiteIntArray*)&g0::tensor_dimension9, 8, },
{ kTfLiteArenaRw, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension10, 8, },
};

#ifndef TF_LITE_STATIC_MEMORY
TfLiteNode tflNodes[4] = {
{ (TfLiteIntArray*)&g0::inputs0, (TfLiteIntArray*)&g0::outputs0, (TfLiteIntArray*)&g0::inputs0, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata0)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs1, (TfLiteIntArray*)&g0::outputs1, (TfLiteIntArray*)&g0::inputs1, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata1)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs2, (TfLiteIntArray*)&g0::outputs2, (TfLiteIntArray*)&g0::inputs2, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata2)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs3, (TfLiteIntArray*)&g0::outputs3, (TfLiteIntArray*)&g0::inputs3, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata3)), nullptr, 0, },
};
#else
TfLiteNode tflNodes[4] = {
{ (TfLiteIntArray*)&g0::inputs0, (TfLiteIntArray*)&g0::outputs0, (TfLiteIntArray*)&g0::inputs0, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata0)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs1, (TfLiteIntArray*)&g0::outputs1, (TfLiteIntArray*)&g0::inputs1, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata1)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs2, (TfLiteIntArray*)&g0::outputs2, (TfLiteIntArray*)&g0::inputs2, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata2)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs3, (TfLiteIntArray*)&g0::outputs3, (TfLiteIntArray*)&g0::inputs3, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata3)), nullptr, 0, },
};
#endif

used_operators_e used_ops[] =
{OP_FULLY_CONNECTED, OP_FULLY_CONNECTED, OP_FULLY_CONNECTED, OP_SOFTMAX, };


// Indices into tflTensors and tflNodes for subgraphs
const size_t tflTensors_subgraph_index[] = {0, 11, };
const size_t tflNodes_subgraph_index[] = {0, 4, };

// Input/output tensors
static const int in_tensor_indices[] = {
  0, 
};

static const int out_tensor_indices[] = {
  10, 
};


size_t current_subgraph_index = 0;

static void init_tflite_tensor(size_t i, TfLiteTensor *tensor) {
  tensor->type = kTfLiteFloat32;
  tensor->is_variable = 0;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  tensor->allocation_type = tensorData[i].allocation_type;
#else
  tensor->allocation_type = (tensor_arena <= tensorData[i].data && tensorData[i].data < tensor_arena + kTensorArenaSize) ? kTfLiteArenaRw : kTfLiteMmapRo;
#endif
  tensor->bytes = tensorData[i].bytes;
  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  if(tensor->allocation_type == kTfLiteArenaRw){
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
      tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
  tensor->quantization.type = kTfLiteNoQuantization;

}

static void init_tflite_eval_tensor(int i, TfLiteEvalTensor *tensor) {

  tensor->type = kTfLiteFloat32;

  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  auto allocation_type = tensorData[i].allocation_type;
  if(allocation_type == kTfLiteArenaRw) {
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
    tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
}

static void* overflow_buffers[EI_MAX_OVERFLOW_BUFFER_COUNT];
static size_t overflow_buffers_ix = 0;
static void * AllocatePersistentBufferImpl(struct TfLiteContext* ctx,
                                       size_t bytes) {
  void *ptr;
  uint32_t align_bytes = (bytes % 16) ? 16 - (bytes % 16) : 0;

  if (current_location - (bytes + align_bytes) < tensor_boundary) {
    if (overflow_buffers_ix > EI_MAX_OVERFLOW_BUFFER_COUNT - 1) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d, does not fit in tensor arena and reached EI_MAX_OVERFLOW_BUFFER_COUNT\n",
        (int)bytes);
      return NULL;
    }

    // OK, this will look super weird, but.... we have CMSIS-NN buffers which
    // we cannot calculate beforehand easily.
    ptr = ei_calloc(bytes, 1);
    if (ptr == NULL) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d\n", (int)bytes);
      return NULL;
    }
    overflow_buffers[overflow_buffers_ix++] = ptr;
    return ptr;
  }

  current_location -= bytes;

  // align to the left aligned boundary of 16 bytes
  current_location -= 15; // for alignment
  current_location += 16 - ((uintptr_t)(current_location) & 15);

  ptr = current_location;
  memset(ptr, 0, bytes);

  return ptr;
}

typedef struct {
  size_t bytes;
  void *ptr;
} scratch_buffer_t;

static scratch_buffer_t scratch_buffers[EI_MAX_SCRATCH_BUFFER_COUNT];
static size_t scratch_buffers_ix = 0;

static TfLiteStatus RequestScratchBufferInArenaImpl(struct TfLiteContext* ctx, size_t bytes,
                                                int* buffer_idx) {
  if (scratch_buffers_ix > EI_MAX_SCRATCH_BUFFER_COUNT - 1) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d, reached EI_MAX_SCRATCH_BUFFER_COUNT\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffer_t b;
  b.bytes = bytes;

  b.ptr = AllocatePersistentBufferImpl(ctx, b.bytes);
  if (!b.ptr) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffers[scratch_buffers_ix] = b;
  *buffer_idx = scratch_buffers_ix;

  scratch_buffers_ix++;

  return kTfLiteOk;
}

static void* GetScratchBufferImpl(struct TfLiteContext* ctx, int buffer_idx) {
  if (buffer_idx > (int)scratch_buffers_ix) {
    return NULL;
  }
  return scratch_buffers[buffer_idx].ptr;
}

static const uint16_t TENSOR_IX_UNUSED = 0x7FFF;

static void ResetTensors() {
  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    tflTensors[ix].index = TENSOR_IX_UNUSED;
  }
  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    tflEvalTensors[ix].index = TENSOR_IX_UNUSED;
  }
}

static TfLiteTensor* GetTensorImpl(const struct TfLiteContext* context,
                               int tensor_idx) {

  tensor_idx = tflTensors_subgraph_index[current_subgraph_index] + tensor_idx;

  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    // already used? OK!
    if (tflTensors[ix].index == tensor_idx) {
      return &tflTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_tensor(tensor_idx, &tflTensors[ix].tensor);
      tflTensors[ix].index = tensor_idx;
      return &tflTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_TENSOR_COUNT (%d)\n", MAX_TFL_TENSOR_COUNT);
  return nullptr;
}

static TfLiteEvalTensor* GetEvalTensorImpl(const struct TfLiteContext* context,
                                       int tensor_idx) {

  tensor_idx = tflTensors_subgraph_index[current_subgraph_index] + tensor_idx;

  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    // already used? OK!
    if (tflEvalTensors[ix].index == tensor_idx) {
      return &tflEvalTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflEvalTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_eval_tensor(tensor_idx, &tflEvalTensors[ix].tensor);
      tflEvalTensors[ix].index = tensor_idx;
      return &tflEvalTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_EVAL_COUNT (%d)\n", (int)MAX_TFL_EVAL_COUNT);
  return nullptr;
}

class EonMicroContext : public MicroContext {
 public:
 
  EonMicroContext(): MicroContext(nullptr, nullptr, nullptr) { }

  void* AllocatePersistentBuffer(size_t bytes) {
    return AllocatePersistentBufferImpl(nullptr, bytes);
  }

  TfLiteStatus RequestScratchBufferInArena(size_t bytes,
                                           int* buffer_index) {
  return RequestScratchBufferInArenaImpl(nullptr, bytes, buffer_index);
  }

  void* GetScratchBuffer(int buffer_index) {
    return GetScratchBufferImpl(nullptr, buffer_index);
  }
 
  TfLiteTensor* AllocateTempTfLiteTensor(int tensor_index) {
    return GetTensorImpl(nullptr, tensor_index);
  }

  void DeallocateTempTfLiteTensor(TfLiteTensor* tensor) {
    return;
  }

  bool IsAllTempTfLiteTensorDeallocated() {
    return true;
  }

  TfLiteEvalTensor* GetEvalTensor(int tensor_index) {
    return GetEvalTensorImpl(nullptr, tensor_index);
  }

};


} // namespace

TfLiteStatus tflite_learn_5_init( void*(*alloc_fnc)(size_t,size_t) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  tensor_arena = (uint8_t*) alloc_fnc(16, kTensorArenaSize);
  if (!tensor_arena) {
    ei_printf("ERR: failed to allocate tensor arena\n");
    return kTfLiteError;
  }
#else
  memset(tensor_arena, 0, kTensorArenaSize);
#endif
  tensor_boundary = tensor_arena;
  current_location = tensor_arena + kTensorArenaSize;

  EonMicroContext micro_context_;
  
  // Set microcontext as the context ptr
  ctx.impl_ = static_cast<void*>(&micro_context_);
  // Setup tflitecontext functions
  ctx.AllocatePersistentBuffer = &AllocatePersistentBufferImpl;
  ctx.RequestScratchBufferInArena = &RequestScratchBufferInArenaImpl;
  ctx.GetScratchBuffer = &GetScratchBufferImpl;
  ctx.GetTensor = &GetTensorImpl;
  ctx.GetEvalTensor = &GetEvalTensorImpl;
  ctx.ReportError = &MicroContextReportOpError;

  ctx.tensors_size = 11;
  for (size_t i = 0; i < 11; ++i) {
    TfLiteTensor tensor;
    init_tflite_tensor(i, &tensor);
    if (tensor.allocation_type == kTfLiteArenaRw) {
      auto data_end_ptr = (uint8_t*)tensor.data.data + tensorData[i].bytes;
      if (data_end_ptr > tensor_boundary) {
        tensor_boundary = data_end_ptr;
      }
    }
  }

  if (tensor_boundary > current_location /* end of arena size */) {
    ei_printf("ERR: tensor arena is too small, does not fit model - even without scratch buffers\n");
    return kTfLiteError;
  }

  registrations[OP_FULLY_CONNECTED] = Register_FULLY_CONNECTED();
  registrations[OP_SOFTMAX] = Register_SOFTMAX();

  for (size_t g = 0; g < 1; ++g) {
    current_subgraph_index = g;
    for(size_t i = tflNodes_subgraph_index[g]; i < tflNodes_subgraph_index[g+1]; ++i) {
      if (registrations[used_ops[i]].init) {
        tflNodes[i].user_data = registrations[used_ops[i]].init(&ctx, (const char*)tflNodes[i].builtin_data, 0);
      }
    }
  }
  current_subgraph_index = 0;

  for(size_t g = 0; g < 1; ++g) {
    current_subgraph_index = g;
    for(size_t i = tflNodes_subgraph_index[g]; i < tflNodes_subgraph_index[g+1]; ++i) {
      if (registrations[used_ops[i]].prepare) {
        ResetTensors();
        TfLiteStatus status = registrations[used_ops[i]].prepare(&ctx, &tflNodes[i]);
        if (status != kTfLiteOk) {
          return status;
        }
      }
    }
  }
  current_subgraph_index = 0;

  return kTfLiteOk;
}

TfLiteStatus tflite_learn_5_input(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(in_tensor_indices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_5_output(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(out_tensor_indices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_5_invoke() {
  for (size_t i = 0; i < 4; ++i) {
    ResetTensors();

    TfLiteStatus status = registrations[used_ops[i]].invoke(&ctx, &tflNodes[i]);

#if EI_CLASSIFIER_PRINT_STATE
    ei_printf("layer %lu\n", i);
    ei_printf("    inputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].inputs->size; ix++) {
      auto d = tensorData[tflNodes[i].inputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");

    ei_printf("    outputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].outputs->size; ix++) {
      auto d = tensorData[tflNodes[i].outputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");
#endif // EI_CLASSIFIER_PRINT_STATE

    if (status != kTfLiteOk) {
      return status;
    }
  }
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_5_reset( void (*free_fnc)(void* ptr) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  free_fnc(tensor_arena);
#endif

  // scratch buffers are allocated within the arena, so just reset the counter so memory can be reused
  scratch_buffers_ix = 0;

  // overflow buffers are on the heap, so free them first
  for (size_t ix = 0; ix < overflow_buffers_ix; ix++) {
    ei_free(overflow_buffers[ix]);
  }
  overflow_buffers_ix = 0;
  return kTfLiteOk;
}
